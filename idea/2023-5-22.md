今天做完了CS:APP的attack lab
虽然我只做了data lab、bomb lab、attack lab
突然觉得很感慨啊，真心觉得这本书的作者非常的用心
这里我打算分享一些我用到知识吧，后面有可能分享一点离散数学的合集内容（单纯因为发现一本好书跟离散老师讲的知识路线高度一致~~离散老师太抽象了~~）

# data lab
- 部分难度很高，掉光头发也想不清楚
- 慢慢做吧，需要非常大的耐心，题目要求其实都挺明确的，只是限制太多
- 总结
  - 会对移位操作，对异或与等操作非常熟悉
  - 会对整数、浮点数的二进制表示以及特性非常熟悉
# bomb lab
难度蛮高的，不要头铁去试错

- 工具gdb、objdump、tab
  - gdb
    - 整个过程与gdb密切相关，需要熟练掌握
    - *gdb **可执行文件*** 其中可执行文件在Linux系统里有一个齿轮的标志
    - *ctrl x + a* 先按*ctrl x*再按*a* 打开tui图形界面
    - *ctrl x + 1* 打开一个资源界面
    - *layout asm* 展示汇编代码
    - *ctrl x + 2* 打开两个资源界面，一般下面这个是汇编代码，上面可以是别的资源
    - *layout regs* 展示寄存器
    - *break _*
      - *break **function*** 其中function是你想要打断点的函数汇编代码
      - *break ***地址值** * 其中地址值前面需要加星号
      - *break _*也可写成*b _*
    - *run _*
      - 不带东西就是手写输入，因为这个lab有很多关，所以不建议手写，太麻烦
      - 带文件名（相对路径）
        - 比如./ans.txt 意思就是该文件夹里的ans.txt文件，前提是你有这个文件
        - 如果在同一文件夹*ans.txt*也是可以的
        - 建议在ans.txt里面每一行写入每一关的答案(输入对格式要求其实不大，通过换行来表示下一关)
      - 同样*run _*也可以写成*r _*
    - *continue*
      - 无情的爆炸工具，不建议尝试，太容易引爆炸弹了
      - 同样*continue*也可以写成*c*
    - *next*
      - 执行到下一个断点
      - 同样*next*也可以写成*n*
    - *nexti*
      - 执行下一步，最常用的指令
      - *ni*
  - objdump
    - 整个过程关系不大，不用也行
    - *objdump -t* 打印符号表
    - *objdump -d* 汇编代码
  - tab
    - tab键是Linux系统里面最方便的一个键
      - 当信息足够时，一次tab键可以补全命令
      - 当信息不足时，连续快速敲击tab键可以给出备选列表
- 大致流程
  - *gdb bomb*
  - *ctrl x + a*
  - *ctrl x + 2*
  - *layout regs* 当输入*lay*的时候可以按tab
  - *b explode_bomb* 当输入*b exp*的时候可以按tab
  - *b **xxx*** 可以多打几个断点
  - *r ./ans.txt*
  - *ni* 一步一步尝试猜测答案
- 总结
  - 新手不熟悉指令的话，巨容易把炸弹引爆，建议先从指令学起
  - 做完之后，会对寄存器的理解提高非常多
  - 会做的人自然很快做出来的，不会做的人需要慢慢猜~~谁让我这么菜呢？~~
# attack lab
继bomb lab的一次lab，难度没那么高，但有很多原理说清楚了

- 工具gdb、objdump、hex2raw
  - gdb
    - 作用蛮小的，主要是阅读代码
    - 因为用的蛮熟练的，这里给出我用到的一些快捷键
      - *gdb **可执行文件*** 其中可执行文件在Linux系统里有一个齿轮的标志
      - *ctrl x + a* 先按*ctrl x*再按*a* 打开tui图形界面
      - *ctrl x + 1* 打开资源界面
      - *layout asm* 展示汇编代码
      - *disassemble **function*** 其中function是你想要查看的函数汇编代码
  - objdump
.    - 还行，没什么用
    - *objdump -d **xx.o** > **xx.d*** 其中xx.o是gcc编译出来的文件，也就是说使用这条代码之前，你需要*gcc -c **xx.s***
  - hex2raw
    - 打包下载的可执行程序，蛮好用的
    - 负责将16进制的代码转成字符串
    - *./hex2raw < **xx.txt** > **xxx.txt*** 其中xx.txt是你写的16进制代码，xxx.txt是输出的字符串
      - 似乎你写的xx.txt文件里面空格和回车是不被区分的，然后就是每两个数字间隔一下
- 大致流程
  - 了解你栈的开辟空间大小，在getbuf函数第一行就告诉你的，你之后的16进制文件就要按照这个空间做操作
  - 善用ret，通过让buf溢出，修改ret要到的地址，在gdb中你能读到的地址都能访问
    - 每一个16进制的两个数字代表一位地址，函数与函数之间没有空地址，在地址上都是连续的
    - 按顺序，越往后走，越往下走，地址就越大
    - 小端法，输入对应地址时，需要倒着顺序写
  - 修改寄存器的值，在学会ret之后，但不会修改值
  - 别怕，可以写一个*xx.s*文件，用上movl、pushq等指令，然后交给gcc、objdump就可以得到对应的十六进制代码
- 整理一下，前面3关是简单版本，第4关是第2关的困难版，第5关是第3关的困难版
- 整个流程搞完之后会对栈和寄存器的理解加深
- 在Linux系统中"<"表示文件的输入，">"表示文件的输出，这个非常好用，甚至我记得windows好像也有这个功能
# 总结
其实三个lab都非常有意思啊，只不过其中有很多过程蛮劝退的
- 阅读题干
  - 题干往往是特别难读的，写的~~又臭又长~~非常齐全，对于我这种捞起半截就跑的人来说，就是噩梦
  - 总会出现一些陌生的词汇，要想直接开始做题是非常困难的
  - 需要非常耐心，里面有很多细节被藏起来了~~我觉得没必要藏其实~~，需要多思考
- debug
  - 总有很多困难在干扰你，一次又一次debug，最后对知识变得熟练
  - 看不见头啊，永远不知道什么时候能做对
- 工具掌握
  - 有很多工具没说用法，得自己去试验